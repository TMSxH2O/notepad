# Java 面试

> by https://www.bilibili.com/video/BV1zb411M7NQ?from=search&seid=5638984729110659811

## JUC

JUC，指的是 `java.util.concurrent` 包以及其子包中的内容

### volatile

volatile 是 Java 虚拟机提供的**轻量级**（主要体现在原子性）的同步机制，其主要可以实现以下的效果

- 保证可见性
- 禁止指令重排
- ==不保证原子性==

> 为了能够更加清晰此处的各个特性的效果，此处需要引入 `JMM` Java 内存模型
>
> volatile 基本上遵守了 JMM

#### JMM

JMM，Java Memory Model，Java 内存模型

本身是一种抽象的概念并<u>不真实存在</u>，描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段、静态资源和构成数组对象的元素）的访问方式

***JMM 同步规定***

1. 线程解锁前，必须把共享变量的值刷新会主内存
2. 线程加锁前，必须把读取主内存的最新值加载到自己的工作内存中
3. 加锁解锁是同一把锁

由于 JVM 运行程序的实例是线程，而每个线程创建时 JVM 都会为其创建一个工作内存（或也能被称为栈空间），工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量都存储在**主内存**

**主内存**是共享内存区域，所有线程都可以访问，但<u>线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到独立线程的工作空间中，然后对变量进行操作，操作完成后再将变量协会主内存</u>

不能直接操作主内存中的变量，各个线程中的工作内存中存储这主内存的**变量副本拷贝**，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成

![面试-JUC-volatile-JMM-访问过程](img/%E9%9D%A2%E8%AF%95-JUC-volatile-JMM-%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B.png)

而这样的，不同线程之间的变量修改，导致了同一个共享变量的改变，这样在主内存中的修改，能够让其他线程也能通过通知获取到到变量的改变，这样的性值，就被称为==***可见性***==

##### 特性

JMM 的三大特性

- 可见性
- 原子性
- 有序性

> 与 volatile 和相比，是一种规范
>
> volatile 更加轻量，主要体现在没有实现原子性

###### 可见性

在线程中，操作的公共变量，默认情况下，是各个线程对主内存中的公共变量的拷贝，即并没有真正直接操作公共变量，而只是在使用镜像

在线程独立的工作空间中，如果对公共变量的修改，会希望导致公共变量值的修改，然后默认情况下，其他线程并不能了解到公共变量已经发生了变化

如果公共变量发生了修改，就能通知所有线程一同进行修改

这样的性值，就是==可见性==

---

在代码中感受，如果没有使用 `volatile` 关键字，使用一个线程在其中修改公共变量（对象）中的属性，而之后的 `main` 线程并不能获取到其中数据的变化

```java
/* 创建一个测试类
其中用于测试的属性 num，没有使用 volatile 来保证其可见性
此时，在线程中的修改，不会影响到其他线程
*/
class TestVolatile {
  int num = 0;

  public void setNum (int num) {
    this.num = num;
  }
}

/* junit4 接口测试 */
@Test
public void test7() {
  TestVolatile test = new TestVolatile();

  // 匿名内部类，创建线程并在其中修改了公共变量 TestVolatile 中的属性 num
  new Thread(() -> {
    System.out.println("[before] num = " + test.num);
    try {
      // 暂停两秒
      TimeUnit.SECONDS.sleep(2);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }

    test.setNum(20);
    System.out.println("[After] num = " + test.num);
  }, "").start();
  
	// 因为没有保证可见性，此处的循环无法退出
  while (test.num == 0) {
    //            System.out.println("[Main] num == 0");
  }

  System.out.println("TestVolatile 中的 num 值被修改");
}
```

如果在此处的 `TestVolatile` 的 `num` 属性前添加 `volatile` 关键字，就能正常退出循环，并出现之后的输出

> 通过 JMM 的基本概念以及运作流程图，可以直到
>
> 各个线程对主内存中共享变量的操作都是<u>各自的工作内存</u>进行操作后在写到主内存中
>
> 这样就可能导致线程修改一个共享变量的值还没有协会主内存，而另一个线程也对共享变量进行了操作，这样就可能导致出现了主内存和工作内存中出现了同步延迟现象，也就造成了可见性的问题

###### 原子性

不可继续分割，自身具有完整性，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整

**要么整体成功，要么整体失败**

==volatile 并不保证原子性==

```java
class TestVolatile {
  volatile int num = 0;

  public void setNum (int num) {
    this.num = num;
  }

  /**
   * 自增方法
   */
  public void numPlus () {
    ++ this.num;
  }
}

@Test
public void test8() {
  TestVolatile test = new TestVolatile();

  // 生成20个线程，每个线程中自增5次
  // 理想中最终获取到的值应该为20000
  for (int i = 0; i < 20; i++) {
    new Thread(() -> {
      for (int j = 0; j < 1000; j++) {
        test.numPlus();
      }
    }, String.valueOf(i)).start();
  }

  // 等待所有线程运行结束，并获取最终的值
  // 等待的实现方式，可以直接等待一定时间
  // 使用Thread中的activeCount()方法来判断
  //   默认情况下，jvm中必然会有gc线程，同时此处应该还有main线程
  while (Thread.activeCount() > 2) {
    Thread.yield();
  }

  System.out.println("最终的num值：" + test.num);
}
```

其中的期望结果值为 20000， 但是最终的结果一般都会小于这个期望值

此处可以使用以下的方式来实现原子性：

1. 使用 `synchronized` 来实现同步，其中完全实现了 JMM 的标准

2. 使用 `JUC` 中提供的满足原子性的基础数据类型的包装类

   如，此处使用 `AtomicInteger` 包装类，使用其中的 `incrementAndGet()` 实现自增（逻辑与 `volatile` 例子相同），最终的结果一定是 20000

###### 有序性

计算机在执行程序时，为了提高性能，编译器和处理器常常会对***指令进行重排***，一般分为以下三种情况

1. 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致【单线程不会对最终效果产生影响】
2. 编译器在进行重排序必须要考虑指令之间的**<u>数据依赖性</u>**【编译器中优化的前提，先有数据声明，才会有数据操作】
3. 多线程环境中，线程交替执行，由于编译器优化重排的存在（客观存在），<u>两个线程中使用的变量能否保证一致性是无法确定的，这就造成了**结果无法预测**</u>

结合下图进行理解，高级语言需要被转换为汇编语言之后再转换为机器语言，而在很多时候，其中具体的各个汇编语言的执行并非严格按照顺序依次执行，而是为了提升效率动态执行（会优先考虑数据依赖性，即基本的逻辑，必须先有数据才能操作数据）

![面试-JUC-volatile-JMM-有序性-编译流程示意图](img/%E9%9D%A2%E8%AF%95-JUC-volatile-JMM-%E6%9C%89%E5%BA%8F%E6%80%A7-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

### CAS

比较并交换，是一条 CPU 并发原语。主要是能够判断内存中某个位置的值是否为预期值，如果是则更新为新的值，这个过程应该是原子的

代表的是 `JUC` 下所提供的 `Unsafe` 类中的 `compareAndSwap()` 方法

> CAS 也被称为乐观锁；相对的 `synchronized` 被称为悲观锁

> 默认情况下，在 `JUC` 下满足原子性的包装类，其中就存在方法 `compareAndSet()` 其中的具体实现就是使用的 CAS 也就是 `compareAndSwap()` 方法

CAS 并发原语体现在 Java 语言中就是 `sun.misc.Unsafe` 类中的各个方法

通过调用 `Unsafe` 类中的 CAS 方法，JVM 会自动实现 CAS <u>汇编命令</u>。这是一种完全依赖**硬件**的功能，通过其能够实现原子操作

由于 CAS 是一种系统原语，原语属于操作系统用于范畴，是由若干指令组成，用于完成某个功能的一个过程，并且==原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，不会造成所谓的数据不一致问题==

#### Unsafe

`Unsafe` 是 CAS 的核心，由于 Java 方法无法直接访问底层系统，需要通过本地的 `native` 方法来进行访问，`Unsafe` 相当于预留的后门，基于该类就可以直接操作特定内存的数据

`Unsafe` 类存在于 `sun.misc` 保重，其内部的方法操作可以像 `C` 指针一样直接操作内存，因此 Java 中 CAS 操作的执行依赖于 `Unsafe`

注意 `Unsafe` 类中的所有方法基本上都是使用 `native` 修饰的，也就是说 `Unsafe` 类中的方法都可以直接调用操作系统底层资源，来执行对应的任务

在 `Unsafe` 类中的核心，主要体现在变量 `valueOffset`和 变量 `value`

- `valueOffset` 表示了变量在内存中的编译地址

  > `Unsafe` 就是通过内存偏移地址来获取数据的

- `value` 使用了 `volatile` 关键字修饰，保证了其内存可见性

---

在其内部的方法 CAS 实现，主要使用了 `Unsafe` 中的（此处使用 `int` 类型进行讲解）`getAndAddInt(Object, long, int)` 方法

其中，因为是 get and add，即先获取值，再增加值；之后的获取值以及增加值都在循环中，其退出的条件被设定为成功修改，即获取到值之后进行修改，在主内存中的地址处的值与此处的期望值（刚刚获取到的值）相等，就能成功进行修改

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
  int var5;
  do {
    var5 = this.getIntVolatile(var1, var2);
  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

  return var5;
}
```

> 通过**自旋锁**的方法实现

#### 优缺点

> 主要与 `synchronized` 进行比较
>
> 一致性保证，但并发性下降

##### 优点

与 `synchronized` 相比，有更强的并发性，允许多个线程共同操作同一个变量

##### 缺点

- 循环时间长，开销大
- 只能保证一个共享变量的原子操作
- ==引出 ABA 的问题==

#### ABA 问题

在CAS算法中，需要取出内存中某时刻的数据（由用户完成），在下一时刻比较并替换（由CPU完成，该操作是原子的）。这个时间差中，会导致数据的变化。

假设如下事件序列：

1. 线程 1 从内存位置V中取出A。
2. 线程 2 从位置V中取出A。
3. 线程 2 进行了一些操作，将B写入位置V。
4. 线程 2 将A再次写入位置V。
5. 线程 1 进行CAS操作，发现位置V中仍然是A，操作成功。

尽管线程 1 的CAS操作成功，但不代表这个过程没有问题——*对于线程 1 ，线程 2 的修改已经丢失*

##### 时间戳原子引用

为了解决 ABA 问题，使用的一个思路

在 JUC 中提供了 `AtomicStampedReference<?>` 类，能够在原本的基础上，添加一个 `int` 值，用于存储版本号(`Stamp`)

- `AtomicStampedReference(Ojbect, int)` 【**构造方法**】

  构造函数需要接收初始值，以及初始版本号

  ---

- `getStamp()` `return int` 

  返回版本号

- `getReference()` `return Object`

  返回其中存储的参数值

#### 自定义类型 CAS 代码

通过使用 `AtomicReference<?>` 类

```java
/* User 类
其中的getter、setter等方法省略
*/
class User {
  String username;
  int age;
}

public class AtomicReferenceDemo{
  public static void main(String[] args) {
    User u1 = new User("test1", 20);
    User u2 = new User("admin", 80);

    AtomicReference<User> userReference = new AtomicReference<>();
    // 设置其中的User对象为u1
    userReference.set(u1);

    // 将u1换为u2
    System.out.println(userReference.compareAndSet(u1, u2)) + "\t" + userReference.get().toString());
  }
}
```

#### 拓展

##### 聚合并发错误

> 此处以 `ArrayList` 为例

在 Java 集合框架中，默认情况下，并不是线程安全的

其中，没有使用 `synchronized` 也没有任何的控制操作，因此在多线程的环境下将会出现大量的异常

其中==最常见的异常==是：

`java.util.ConcurrentModificationException`

###### 错误原因分析

多线程情况下，不同线程之间的竞争，会导致各个线程之间的操作发生冲突，导致数据不一致，即造成并发数据修改异常

> 多个线程同时对一个集合进行添加元素并输出，出现 `ConcurrentModificationException` 异常并不是 `add()` 方法出错，而是之后的输出中，即 `toString()` 中，读取集合时，因为多线程竞争，导致了 `modCount != expectedCount` 所导致的异常

###### 解决方案

1. 修改方法加锁（如此处的 `ArrayList` 存在加所实现的 `Vector`）

2. 使用 `Collections` 工具类中提供的方法，将集合转换为线程安全的集合（此处的 `ArrayList` 可以使用 `Collections.synchronizedList(new ArrayList<>())` 来实现

3. 【写时复制】使用 `JUC` 下提供的 `CopyOnWrite..` 类

   原本对集合中数组（底层）的操作，<u>不再对原数组进行操作</u>，转而**新建/复制一个数组**，在新数组中完成操作后，将集合底层用于存储的数组指向新数组

   > 写时复制是指：在并发访问的情景下，当需要修改 Java 中Containers的元素时，不直接修改该容器，而是先复制一份副本，在副本上进行修改。修改完成之后，将指向原来容器的引用指向新的容器(副本容器)

```java
/* CopyOnWriteArrayList.add() */
public boolean add(E e) {
  final ReentrantLock lock = this.lock;
  lock.lock();
  try {
    Object[] elements = getArray();
    int len = elements.length;
    Object[] newElements = Arrays.copyOf(elements, len + 1);
    newElements[len] = e;
    setArray(newElements);
    return true;
  } finally {
    lock.unlock();
  }
}
```

> `HashMap` 的写时复制类是 `ConcurrentHashMap`

### 锁

Java 中的各种锁

*公平锁、非公平锁、可重入锁、递归锁、自旋锁*

#### 公平/非公平锁

- 公平锁

  多个线程按照<u>申请锁的顺序来获取锁</u>，类似排队打饭，先来后到

  公平锁，就是很公平，在并发环境中，每个线程在获取锁是会查看此锁维护的等待队列。如果队列为空，或者当前线程是等待队列的第一个，就会占有锁；否则加入等待队列，以后会按照 `FIFO` 的规则从等待队列中获取，并依次占有锁

- 非公平锁

  多个线程获取锁的顺序并<u>不是按照申请锁的顺序</u>，有可能后申请的线程优先获取锁

  ==在高并发的情况下，有可能造成优先级反转或者饥饿现象==

  非公平锁比较粗暴，会直接尝试占有锁。如果正好锁始放就能直接获取锁；如果尝试失败，就会采用类似公平锁的方式

> 通过使用 `ReentrantLock` 的构造函数来分别构建公平锁或非公平锁
>
> - 【**默认情况，无参构造**】==非公平锁==
> - 其中传入一个 `boolean` 值，如果为 `true`，会生成==公平锁==；如果为 `false`，会生成==非公平锁==
>
> `synchronized` 也是使用非公平锁

**<u>非公平锁的吞吐量比公平锁大</u>**

#### 可重用锁

可重用锁，也被称为递归锁

指的是同一个线程外层函数获取锁之后，内存递归函数仍然能够获取该锁的代码；在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁

也就是说，**线程可以进入任意一个已经拥有锁所同步的代码块**

```java
// 外层的锁
// 之后会将外层的锁传给method2()（method2将使用同样的锁）
public synchronized void method1() {
  method2();
}
// 内层同步锁，只要获取了外层锁，如果内层使用的是相同的锁，就可以直接进入内层
public synchronized void method2() {
  
}

/******************使用Lock***********************/
// 声明一个相同的Lock
Lock lock = new ReentrantLock();
public void method1() {
  lock.lock();
  try {
    // 方法体
  } finally {
    lock.unlock();
  }
}

public void method1() {
  lock.lock();
  try {
    // 方法体
  } finally {
    lock.unlock();
  }
}
```

> `ReentrantLock` 和 `synchronized` 都是典型的可重用锁

**<u>可重用锁最大的效果就是可以避免死锁</u>**

#### 自旋锁

是指**尝试获取锁的线程不会立即<u>阻塞</u>，而是采用循环的方式去尝试获取锁**，这样的好处是可以减少线程上下文切换的消耗，缺点是会消耗 CPU

> 经典的使用场景就是 JUC 下的原子包装类，如 `AtomicInteger`

```java
AtomicReference<Thread> atomicReference = new AtomicReference<>();

public void myLock() {
  Thread thread = Thread.currentThread();
  System.out.println(thread.getName() + "\t myLock()");
  
  while (!atomicReference.compareAndSet(null, thread)) {
    
  }
}

public void myUnlock() {
  Thread thread = Thread.currentThread();
  // 将其中的值值设置为null
  // 如果转换失败，说明本来就没有上锁
  atomicReference.compareAndSet(thread, null);
}

public static void main(String[] args) {
  // 本类为 MyLockTest，其中有 myLock() 和 myUnlock() 方法
  MyLockTest test = new MyLockTest();
  
  new Thread(() -> {
    test.myLock();
    try {
      // 睡眠3秒
      TimeUtil.SECONDS.sleep(3);
    } catch (Exception e) {
      e.printStackTrace();
    }
    test.myUnlock();
  }, "T1").start();
  
  new Thread(() -> {
    test.myLock();
    test.myUnlock();
  }, "T2").start();
}
```

#### 独占锁（写锁）/共享锁（读锁）/互斥锁

##### 独占锁

指该锁一次只能被一个线程所持有

对 `ReentrantLock` 和 `synchronized` 而言都是独占锁

##### 共享锁

指该锁可被多个线程所持有

##### 结合使用

对 `ReentrantReadWriteLock` 其读锁是共享锁，其写锁是独占锁

- 全部读

  可以共存，能够都各线程共同读，不会冲突

- 全部写

  不能共存，不能一同操作，需要锁操作

- 同时读写

  不能共存，不能一同操作，需要锁操作

---

通过这样的概念，在 JUC 中提供了对应的类 `ReentrantReadWriteLock`，用于分别实现读写锁，能够控制写或读时的锁定

其中能够分别控制读和写的锁，如需要进行写锁时，使用其中的 `writeLock()` 方法，来获取写锁，再使用 `lock()` 方法进行锁定

```java
Lock lock = new ReentrantReadWriteLock();

// 使用写锁
lock.writeLock().lock();
try {
  // 需要锁定的写操作
} finally {
  lock.writeLock().unlock();
}

// 使用读锁
lock.readLock().lock();
try {
  // 需要锁定的读操作
} finally {
  lock.readLock().unlock();
}
```

### JUC 中的常用类

#### CountDownLatch

用于控制线程的执行时间，可以控制当前线程的执行时间，主要用于控制其在其他线程的某个时机之后进行执行（如其他线程执行结束之后）

> 某种意义上，与 `Thread.join` 类似，但是略有区别
>
> `CountDownLatch` 可以更加灵活的控制其线程执行的时机，不一定是其他线程执行结束；`Thread.join` 必须是其他线程执行结束之后才能继续

```java
// 设置一个 CountDownLatch
// 此处因为会额外开启 6 个线程，main线程在其他线程都结束的情况下才会执行
CountDownLatch countDownLatch = new CountDownLatch(6);

// 创建6个线程
for (int i = 0; i < 6; ++ i) {
  new Thread(() -> {
    System.out.println(Thread.currentThread().getName() + "\t 线程优先执行");
    // 线程最后需要减少其 CountDownLatch 的计数
    countDownLatch.countDown();
  }, String.valueOf(i)).start();
}

// 等待其他6个线程执行结束，通过的是 CountDownLatch 中的计数进行判断
countDownLatch.await(); // 需要try-catch
System.out.println(Thread.currentThread().getName() + "\t 最终执行");
```

其核心的使用方法就是通过 `CountDownLatch` 的 `await()` 方法阻塞某个线程，其他线程的任意时机使用 `countDown()` 方法，将 `CountDownLatch` 中的计数进行减一，一直到其中的计数为 0 时，就能直接实现 `await()` 线程的释放

#### CyclicBarrier

`CyclicBarrier` 的字面意思是可循环 `Cyclic` 使用的屏障 `Barrier` ，其主要是实现的功能为：**让一组线程到达某个屏障（也被称为同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开启，所有被屏障拦截的线程才会继续干活**。线程进入屏障通过的是 `CyclicBarrier` 的 `await()` 方法

其使用的现象基本上与 `CountDownLatch` 效果相反，一直到其他线程达到某个数量之后，才会对阻塞线程放行

> 可以理解为：开会，只有所有人到齐之后才会开始；集齐7龙珠才能召唤神龙

```java
// 获取 CyclicBarrier
// 其中可以指定等待几个线程，以及最终达到数量之后会执行的线程
// 此处以找到7颗龙珠才能召唤神龙为例
CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {System.out.println("召唤神龙");});

// 创建7个线程，实现找到对应龙珠的方法
for (int i = 1; i <= 7; ++ i) {
  final int temp = i; // 必须使用 final 修饰才能在内部使用
  new Thread(() -> {
    System.out.println(Thread.currentThread().getName() + "\t找到了" + temp + "龙珠");
    cyclicBarrier.await(); // 需要 try-catch
  }, String.valueOf(i)).start();
}
```

#### Semaphore

主要是用来处理多个线程抢占多个资源

> 此处以6辆车抢占3个车位为例

```java
// 获取 Semaphore
// 默契3个停车位
Semaphore semaphore = new Semaphore(3);

for (int i = 1; i <= 6; ++i) {
  new Thread(() -> {
    try {
      // 尝试停车
      semaphore.acquire(); // 需要try-catch，如果没有抢到，会阻塞
      System.out.println(Thread.currentThread().getName()+ "\t抢到了车位");
      try {
        // 停2秒之后始放
        TimeUnit.SECONDS.sleep(2);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      System.out.println(Thread.currrentThread().getName() + "\t停车2秒，已离开");
    } catch (InterruptedException e) {
      e.printStackTrace();
    } finally {
      // 始放停车位
      semaphore.release();
    }
  }, String.valueOf(i)).start();
}
```

### 阻塞队列

当阻塞队列是**空**时，从队列中**获取**元素的操作将被阻塞；当阻塞队列时**满**时，往队列中**添加**元素的操作将会被阻塞

#### 特点

在多线程领域，所谓阻塞，就表示某些情况下**挂起**线程，即阻塞线程，等到满足线程条件之后，被挂起的线程又会被**自动唤醒**

使用了阻塞队列之后，就不需要关心什么时候阻塞线程，什么时候唤醒线程，因为这一切都已经交给了 `BlockingQueue` 进行管理

#### 详细介绍

在 Java 的集合框架中，提供了 `BlockingQueue` 接口，继承了该接口的实现就是阻塞队列

> `Collection` > `Queue` > `BlockingQueue`

以下为7个常见的实现

- ==ArrayBlockingQueue==

  由数组组成的**有界**阻塞队列

- ==LinkedBlockingQueue==

  由链表组成的**有界**（但大小默认值为 `Integer.MAX_VALUE`）阻塞队列【**慎用**】

- PriorityBlockingQueue

  支持优先级排序的**无界**阻塞队列

- DelayQueue

  是有优先级队列实现的延迟**无界**阻塞队列

- ==SynchronousQueue==

  不存储元素的阻塞队列，也即**单个元素**的队列

- LinkedTransferQueue

  由链表组成的**无界**阻塞队列

- LinkedBlocking*Deque*

  由链表组成的双向阻塞队列

#### 核心方法

##### 增

- `add()` `param E` `return boolean`

  如果队列已满，会抛出异常

- `offer()` `param E` `return boolean`

  插入成功返回 true；失败为 false

- `put()` `param E`

  如果队列已满，会阻塞线程，直到队列中有更多的空间为止

- `offer()` `param E, timeout[long], TimeUnit` `return boolean`

  如果队列已满，等待一段时间，如果依然没有空间，就放弃插入，返回 false

##### 删

- `remove()` `return E`

  如果队列为空，会抛出异常

- `poll()` `return E`

  如果有元素返回元素值，否则返回 null

- `take()` `return E`

  如果队列中已经为空，会阻塞线程，直到之后有加入

- `poll()` `param timeout[long], TimeUnit` `return E`

  如果队列为空，等待一段时间，这段时间队列依然为空，没有获取到值，就返回 null

##### 查

- `element()` `return E`

  返回队列首个元素

- `peek()`

  与删相同，队列中有值，就返回队首值；如果没有值，就返回 null

#### 实际使用

具体的使用场景

- **生产者消费者模式**
- 线程池
- 消息中间件

##### 生产者消费者模式

传统代码的代码实现

```java
// 需求：希望两个线程同时操作一个资源类，生产一个资源就被消费一个资源，同时只会存在一个资源
// 测试方法
  Project project = new Project();
  new Thread(() -> {
    for (int i = 0; i < 5; i++) {
      project.increment();
    }
  }, "+").start();

  new Thread(() -> {
    for (int i = 0; i < 5; i++) {
      project.decrement();
    }
  }, "-").start();
/* 资源类 */
class Project {
  public int number = 0;
  public Lock lock = new ReentrantLock();
  public Condition condition = lock.newCondition();

  /**
     * 自增方法
     * 线程同步，只会在number等于0时进行自增操作
     */
  public void increment() {
    // 加锁，线程同步
    lock.lock();
    try {
      // 如果number不等于0，使其等待（类似之前的wait())
      while (number != 0)
        condition.await();
      // 满足条件，自增
      ++number;
      System.out.println(Thread.currentThread().getName() + "\t" + number);
      // 唤醒其他线程（类似之前的notify）
      condition.signalAll();
    } catch (InterruptedException e) {
      e.printStackTrace();
    } finally {
      // 解锁
      lock.unlock();
    }
  }

  /**
     * 自减方法
     * 线程同步，会使number的值1->0
     */
  public void decrement() {
    // 加锁，线程同步
    lock.lock();
    try {
      // 如果number等于0，使其等待
      // 使用while能够防止虚假唤醒
      while (number == 0)
        condition.await();
      // 满足条件，自减
      --number;
      System.out.println(Thread.currentThread().getName() + "\t" + number);
      // 唤醒其他线程
      condition.signalAll();
    } catch (InterruptedException e) {
      e.printStackTrace();
    } finally {
      // 解锁
      lock.unlock();
    }
  }
}
```

使用消息队列的实现

```java
class BlockingQueueProduct {
  private final AtomicInteger integer = new AtomicInteger();
  private volatile boolean flag = true;
  private BlockingQueue<String> blockingQueue = null;

  public BlockingQueueProduct(BlockingQueue<String> blockingQueue) {
    this.blockingQueue = blockingQueue;
  }

  /**
     * 生产方法
     */
  public void product() {
    boolean isTrue;
    while (flag) {
      try {
        isTrue = blockingQueue.offer(integer.incrementAndGet() + "", 1L, TimeUnit.SECONDS);
        if (isTrue) {
          System.out.println(Thread.currentThread().getName() + "\t创建成功\t[" + integer + ']');
        } else {
          System.out.println(Thread.currentThread().getName() + "\t创建失败\t[" + integer + ']');
        }
        TimeUnit.MILLISECONDS.sleep(300);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    System.out.println('\n' + Thread.currentThread().getName() + "\t生产结束");
  }

  public void consume() {
    String value = null;
    while (flag) {
      try {
        value = blockingQueue.poll(2L, TimeUnit.SECONDS);
        if (value == null || value.equalsIgnoreCase("")) {
          flag = false;
          System.out.println(Thread.currentThread().getName() + "\t超时没有获取到产品，退出");
          break;
        }
        System.out.println(Thread.currentThread().getName() + "\t获取到" + value);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }

  public void exit() {
    flag = false;
  }
}

/* 测试方法 */
BlockingQueueProduct product = new BlockingQueueProduct(new ArrayBlockingQueue<>(3));

// 生产线程
new Thread(() -> {
  System.out.println(Thread.currentThread().getName() + "\t生产线程开始运行……\n");
  product.product();
}, "product").start();

// 消费线程
new Thread(() -> {
  System.out.println(Thread.currentThread().getName() + "\t消费线程开始运行……\n");
  product.consume();
}, "consume1").start();
/*new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t消费线程开始运行……\n");
            product.consume();
        }, "consume2").start();*/

try {
  // 主线程等5秒钟
  TimeUnit.SECONDS.sleep(5);
} catch (InterruptedException e) {
  e.printStackTrace();
}
// 停止生产
product.exit();
```

### 多线程的实现

- `extends Thread`

- `implements Runnable`

- `implements Callable<?>` 【**重要**】

  通过 `FutureTask<?>` 来使用

  ```java
  FutureTask<String> futureTask = new FutureTask<>(() -> {
    // 实现了 Callable 接口的 call() 方法
    System.out.println("test Callable");
    int i = 1/0;
    return "test";
  });
  futureTask.run();
  
  try {
    // 通过使用 get() 方法，可以获取其中的返回值，或者是捕获其中的异常
    String s = futureTask.get();
    System.out.println(s);
  } catch (Exception e) {
    System.out.println("捕获了异常");
  }
  ```

### 线程池

Java 中的线程池是通过 `Executor` 框架实现的，该框架中使用到了 `Executor`、`Executors`、`ExecutorService`、`ThreadPoolExecutor` 这几个类

![面试-JUC-线程池-Executor框架-架构](img/%E9%9D%A2%E8%AF%95-JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executor%E6%A1%86%E6%9E%B6-%E6%9E%B6%E6%9E%84.png)

> 其中的 `ThreadPoolExecutor` 就是线程池的底层
>
> 获取线程池是通过 `Executors` 的工具类获取线程池对象

#### 常用线程池

- `Executors.newFixedThreadPool()` `param nThread: int` 

  固定大小的线程池

  主要用于获取执行长期任务的线程池

- `Executors.newSingleThreadExecutor()`

  主要针对需要多次使用的一个线程

- `Executors.newCachedThreadPool()`

  主要用于执行数量不定任务的线程池

  > 会根据线程的处理能力，创建多个线程
  >
  > 如果线程能够处理，就不会创建，新线程；如果不能处理，就会请求更多的线程来动态创建线程

通过源码的分析，这三种 Java 线程池都是使用了 `ThreadPoolExecutor`

> 根据 《阿里巴巴 Java 开发手册》
>
> <u>**不能使用 `Executors` 直接获取内置的线程池**，需要自行使用 `Executor` 来创建定制线程池，同时**不能使用无界阻塞队列**（会造成 OOM）</u>

##### 代码实现

###### `newFixedThreadPool(nThread: int)`

```java
ExecutorService executorService = Executors.newFixedThreadPool(5);
try {
  for (int i = 0; i < 10; i++) {
    // 使用线程池，处理10次请求
    // 此处的效果为线程池中的5个线程来一同完成任务
    executorService.execute(() -> {
      System.out.println(Thread.currentThread().getName() + "\trunning..");
    });
  }
} finally {
  executorService.shutdown();
}
```

###### `newSingleThreadExecutor()`

```java
ExecutorService executorService = Executors.newSingleThreadExecutor();
try {
  for (int i = 0; i < 10; i++) {
    // 使用线程池，处理10次请求
    // 此处的效果为线程池中的一个线程来完成所有的任务
    executorService.execute(() -> {
      System.out.println(Thread.currentThread().getName() + "\trunning..");
    });
  }
} finally {
  executorService.shutdown();
}
```

###### `newCachedThreadPool()`

```java
ExecutorService executorService = Executors.newCachedThreadThreadPool();
try {
  for (int i = 0; i < 10; i++) {
    // 使用线程池，处理10次请求
    // 如果与此处的代码一致，会出现多个线程，甚至会出现10个线程一同处理的情况；如果设置了间隔，可能一个线程就能处理
    executorService.execute(() -> {
      System.out.println(Thread.currentThread().getName() + "\trunning..");
    });
  }
} finally {
  executorService.shutdown();
}
```

##### 自定义线程池

通过 `Executor` 的构造器来创建自定义的线程池

> **需求**
>
> 自定义线程池
>
> - 默认线程池大小为2
> - 最大线程为5
> - 最大生存时间为 1s
> - 使用 `LinkedBlockingQueue<Runnable>`，容量为3
> - 默认线程工厂
> - 默认拒绝策略

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 5, 1L,
                                                               TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(3),
                                                               Executors.defaultThreadFactory(),
                                                               // 使用默认的 AbortPolicy 只要同时塞满最大线程，就会抛出异常
                                                               // 使用 CallerRunsPolicy，如果超出了线程池的承受范围，就会将超出的部分交给原线程（即使用线程池的线程，此处为main线程）处理，不会抛出异常
                                                               // 使用 DiscardOldestPolicy，如果超出了线程池的处理范围，就会抛弃最老/早的任务
                                                               // 使用 DiscardPolicy，如果超出了线程的承受范围，就直接抛弃之后的任务
                                                               new ThreadPoolExecutor.DiscardPolicy());

try {
  for (int i = 1; i <= 20; i++) {
    final int temp = i;
    threadPoolExecutor.execute(() -> {
      System.out.println(Thread.currentThread().getName() + "\t[" + temp + "]\trunning...");
    });
  }
} finally {
  threadPoolExecutor.shutdown();
}
```

#### 线程池原理

通过查看 Java 线程池中的源码，各个线程池底层都是通过使用 `ThreadPoolExecutor` 实现

```java
// newFixedThreadPool
public static ExecutorService newFixedThreadPool(int nThreads) {
  return new ThreadPoolExecutor(nThreads, nThreads,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>());
}

// newSingleThreadExecutor
public static ExecutorService newSingleThreadExecutor() {
  return new FinalizableDelegatedExecutorService
    (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>()));
}

// newCachedThreadPool
public static ExecutorService newCachedThreadPool() {
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue<Runnable>());
}

/* ThreadPoolExecutor */
// 5个参数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
       Executors.defaultThreadFactory(), defaultHandler);
}

// 7个参数【最底层调用】
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
  if (corePoolSize < 0 ||
      maximumPoolSize <= 0 ||
      maximumPoolSize < corePoolSize ||
      keepAliveTime < 0)
    throw new IllegalArgumentException();
  if (workQueue == null || threadFactory == null || handler == null)
    throw new NullPointerException();
  this.acc = System.getSecurityManager() == null ?
    null :
  AccessController.getContext();
  this.corePoolSize = corePoolSize;
  this.maximumPoolSize = maximumPoolSize;
  this.workQueue = workQueue;
  this.keepAliveTime = unit.toNanos(keepAliveTime);
  this.threadFactory = threadFactory;
  this.handler = handler;
}
```

通过源码，可以看到，各个线程池最终都是使用了 `ThreadPoolExecutor` 的7参构造函数，此处的各个参数的定义如下

- `corePoolSize: int`

  线程池中的常驻核心线程数

  可以理解为线程池中默认的线程数

  > 当线程池中的线程数目达到了 `corePoolSize` 后，就会把到达的任务放到<u>阻塞队列</u>中；如果缓冲队列已满而此时线程池中的线程数没有达到 `maximumPoolSize` 就会添加新的线程；如果之后，线程池中的线程数达到了 `maximumPoolSize` 阻塞队列也满了，就会启用<u>拒绝策略</u>

- `maximumPoolSize: int`

  线程池能容纳的最大线程数，此值必须大于等于1

- `keepAliveTime: long`

  多余的线程的存活时间

  当线程池数量超过 `corePoolSize` 时，当空闲时间达到了 `keepAliveTime` 值时，多余的空闲线程会被销毁直到只剩下 `corePoolSize` 这个线程为止

- `unit: TimeUnit`

  `keepAliveTime` 的单位

- `workQueue: BlockingQueue<Runnable>`

  任务队列，被提交但尚未被执行的任务

- `threadFactory: ThreadFactory`

  表示生成线程池中工作线程的线程工厂，用于创建线程

  **一般默认的即可**

- `handler: RejectedExecutionHandler`

  拒绝策略

  队列满了并且工作线程大于等于线程池的最大线程数时，如何拒绝后续的任务

![面试-JUC-线程池-ThreadPoolExecutor-结构图](img/%E9%9D%A2%E8%AF%95-JUC-%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExecutor-%E7%BB%93%E6%9E%84%E5%9B%BE.png)

##### 线程池流程

1. 当创建了线程池，等待提交过来的任务请求

2. 当调用 `execute()` 方法添加一个请求任务时，线程池会做如下判断

   1. 如果正在运行的线程数量小于 `corePoolSize`，那么马上创建线程运行这个任务
   2. 如果正在运行的线程数量大于或等于 `corePoolSize`，那么将这个线程**放入阻塞队列**
   3. 如果这个时候队列满了，并且正在运行的线程数量小于 `maximumPoolSize`，那么还是会创建线程并且立刻运行这个任务
   4. 如果队列满了且正在运行的线程数量大于或等于 `maximumPoolSize`，那么线程池会**启动饱和和拒绝策略来执行**

3. 当一个线程完成任务时，会从队列中取出现一个任务来执行

4. 当一个线程无事可做超过一段时间 `keepAliveTime` 时，线程池会判断：

   如果当前运行的线程数是否大于 `corePoolSize`

   - 如果大于，多余的线程就会被停掉

   <u>控制线程池中的任务到 `corePoolSize` 的大小</u>

#### 线程池配置

##### 拒绝策略

等待队列也已经排满了，已经塞不下新任务，同时线程池中线程的大小也已经达到了 `maximumPoolSize`，无法继续为新任务服务

此时，**就需要一种拒绝策略机制来合理地处理这个问题**

###### JDK 内置拒绝策略

内置了4种拒绝策略

- `AbortPolicy`【**默认**】

  直接抛出 `RejectedExecutionException` 异常阻止系统正常运行

- `CallerRunsPolicy`

  调用者运行，一种调节机制，这种策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量

- `DiscardOldestPolicy`

  抛弃队列中等待最长的任务，然后把当前任务加入队列中尝试再次提交当前任务

- `DiscardPolicy`

  直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这就是最好的一种方案

##### 配置最大线程数

根据具体的 CPU 核心数进行修改，同时不同的场景也也所不同

- CPU 密集型

  一般指的是一直需要 CPU 满速运行的项目

  一般情况是 `CPU 核心数 + 1`（比核心数大1）

  > 以下代码查看 CPU 核心数
  >
  > `Runtime.getRuntime().availableProcessors()`

- IO 密集型

  一般指的是任务线程并不是一直在执行任务，而是在需要时运行尽可能多的线程。因此一般是在系统不会崩溃的情况下，尽量大

  > IO 操作虽然不会占用 CPU 但是会导致 CPU 等待，造成浪费

  此处有两种选择

  - $CPU * 2$

  - $CPU / (1 - 阻塞系数)$ 【此处的阻塞系数一般为 0.8~0.9，越大越乐观】

    IO 密集型，表示该任务需要大量的 IO 操作，即会造成大量的阻塞

    在单线程上运行 IO 密集型任务会导致浪费大量的 CPU 运行能力在等待文件操作上

    因此，在 IO 密集型任务中应该使用多线程可以大大加速程序的运行，即在单线程 CPU 上，这种加速主要是利用了原本被浪费的阻塞时间

### 死锁

死锁指两个或两个以上的线程在执行的过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉就无法继续推进

如果系统的资源充足，死锁出现的可能性就很低；反之，很可能因为争夺优先的资源而出现死锁

#### 实例代码

```java
/* 死锁的类 */
class DeadLockHoldRunnable implements Runnable {
  private String lock1;
  private String lock2;

  public DeadLockHoldRunnable(String lock1, String lock2) {
    this.lock1 = lock1;
    this.lock2 = lock2;
  }

  @Override
  public void run() {
    synchronized (lock1) {
      System.out.println(Thread.currentThread().getName() + "\t持有1锁: " + lock1);
      try {
        TimeUnit.SECONDS.sleep(1);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      synchronized (lock2) {
        System.out.println(Thread.currentThread().getName() + "\t持有2锁: " + lock2);
      }
    }
  }
}

/* 测试的方法 */
String lock1 = "一号锁";
String lock2 = "二号锁";

// 开启两个线程，分别首先获取lock1和lock2
new Thread(new DeadLockHoldRunnable(lock1, lock2), "一号").start();
// 将lock2当作lock1传入
new Thread(new DeadLockHoldRunnable(lock2, lock1), "二号").start();
// 最后会因为互相有对方的锁，而导致死锁
```

#### 如何证明死锁

可以通过 JVM 中的内置工具

```shell
# 查看 Java 进程，会显示进程编号
jps -l

# 查看 Java 某个进程的报告信息
jstack [进程编号]
# 如果存在死锁，会在下方出现 Found 1 deadlock 的报告信息
# 其中还包括锁住的资源信息以及请求的资源信息

# 也可以使用 jconsole 来直接检测线程，其中有检测死锁的功能，能够直接进行加测
```

### 常见面试

#### `synchronized` 和 `lock` 的区别

1. ==原始组成==

   `synchronized` 是关键字，属于JVM层面；`Lock` 是具体的类(`java.util.concurrent.locks.lock`)，是接口层面的锁

   `synchronized` 中，`monitorenter/monitorexit`（底层是通过 `monitor` 对象来实现，其实 `wait/notify` 等方法也依赖与 `monitor` 对象只有在同步块或方法中才能调用 `wait/notify` 等方法）

   > 此处的 `monitorenter` 是通过 `javap` 所看到的汇编代码显示的信息
   >
   > 其中一个 `monitorenter` 一般对应两个 `monitorexit`，分别表示正常退出和异常退出（防止死锁）

2. ==使用方法==

   `synchronized` 不需要用户手动释放锁，会在其代码块执行结束后自动让线程始放对锁的占用

   `Lock` 需要用户手动调用方法来释放锁，如果没有始放，可能导致死锁现象

3. ==是否支持中断==

   `synchronized` 不可以中断，除非抛出异常或者正常执行完成

   `Lock` 可以中断，其中较常见的中断方法有：

   - 设置超时方法 `tryLock(timeout: long, unit: TimeUnit)`
   - `lockInterruptibly()` 放入代码块中，调用 `interrput()` 方法可中断

4. ==加锁是否公平==

   `synchronized` 为非公平锁

   `Lock` 两者都可以，默认为非公平锁。在 `ReentrantLock` 的构造方法中，可以通过传入 `boolean` 值，`true` 为公平锁，`false` 为非公平锁

5. ==锁绑定多个条件==

   `synchronized` 不支持

   `Lock` 用来实现分组唤醒不同的线程，可以实现**精准唤醒**，而不是像 `synchronized` 随机唤醒一个或是唤醒所有

## JVM

> 此处主要是基于 JDK8

### GC

#### 垃圾

简单来说，就是内存中不会再被使用到的空间就是垃圾

##### 如何判断对象是否应该被回收？

在 GC 中，主要存在两种方式

1. 引用计数法
2. 枚举根节点做可达性分析（根探索路径）

###### 引用计数法

在 Java 中，引用和对象是有关联的。如果要操作对象，则必须引用进行。

因此，很显然，一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。其实现就是为对象添加一个引用计数器，每当有地方引用，就为其计数器加一；相对的，如果有地方引用失败，就减一

如果计数器的值为零，就表示该对象不再被使用，表示该对象是可回收对象

> **主流的 Java 虚拟机中都没有使用这样的算法**
>
> 因为引用计数很难解决对象之间互相循环引用的问题
>
> ==了解即可==

###### 枚举根节点做可达性分析（根探索路径）

也被称为 GC roots 或者 tracing GC

为了解决引用计数法中出现的循环引用的问题，Java 使用了**可达性分析**

![面试-JVM-GC-枚举根节点做可达性分析-GC Root](img/%E9%9D%A2%E8%AF%95-JVM-GC-%E6%9E%9A%E4%B8%BE%E6%A0%B9%E8%8A%82%E7%82%B9%E5%81%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-GC%20Root.png)

==基本思路==就是通过一系列名为 **GC roots** 的对象作为起始点，从这个被称为 GC roots 的对象开始向下看所，如果一个对象到 GC roots 没有任何引用链相连时，则说明此对象不可用

即，通过一个给定的集合的引用作为根开始，通过引用关系遍历对象图，能够被遍历到的（可到达的）对象，就被判定为存活；相对的，如果不能遍历到的对象，就被判定为死亡

> **什么样的对象可以被称为 GC roots 对象？**
>
> GC roots 是一个集合，可以理解为 GC roots Set
>
> - 虚拟机栈（栈帧中的局部变量区，也被称为局部变量表）中引用的对象
> - 方法区中的类静态属性引用的对象
> - 方法区中常量引用的对象
> - 本地方法栈中 JNI（Native方法）引用的对象
> - HotSpot 中，使用 OopMap 数据结构存储（对象内偏移量对应的数据类型）在 JIT 编译时，在安全点（safe point）基础栈和寄存器中的引用和对应的位置

#### 垃圾回收算法

主要存在4种最常见的 GC 算法

- 标记-清除算法
- 复制算法
- 标记-压缩算法
- 分代收集算法

##### 标记-清除算法

标记-清除，Mark-Sweep 算法，其算法需要被分为两个阶段：**标记**和**清除**

1. 首先标记处所有需要进行回收的对象
2. 统一回收所有被标记的对象

这是**<u>最基础的回收算法</u>**，因为后续的收集算法都是基于这样的思路进行一定的改进的结果

其中主要存在两个*缺点*

1. 标记和清除的过程效率都不高（也是因为内存碎片的原因）
2. 空间利用率不高，会存在大量的内存碎片

##### 复制算法

复制，Copying 收集算法，可以将可用内存按照内存划分为大小相等的两个部分，每次只使用其中的一块，当这一块的内存耗尽，就会将存活着的对象复制到另一块上，让后再把已经使用过的内存空间清理掉

这样的方式每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按照顺序分析内存即可，实现简单，运行高效

最大的*缺点*就是将<u>内存缩小到的了原来的一般，持续复制生存期长的对象就会导致效率降低</u>

##### 标记-压缩算法

复制收集算法在对象存活率较高的情况，就会执行较多的复制操作，使得效率降低。同时，永远会导致一块空间的浪费，需要额外的空间进行分配担保，以应对被使用的内存中所有对象都 `100%` 的情况，所以在老年代一般不能使用**复制算法**

根据老年代的特点，提出了另一种**标记-整理（Mark-Compact）算法**，标记过程依然与**标记-清除算法**一样，但是后续的步骤不是直接堆可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理边界外的内存

##### 分代收集算法

首先需要满足一个假设：**绝大多数对象的生命周期都非常短站，存活时间短**

分代收集，Generational Collection 算法，其中将 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法

- 在新生代中，每次垃圾收集时都发现有大批对象死亡，只有少量存活，因此选择**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集
- 老年代中因为对象存活率高、没有外空间对其进行分配担保，就必须使用**标记-清理**或**标记-整理**算法进行回收

#### 垃圾回收种类

![面试-JVM-GC-垃圾收集器分类-整理表格](img/%E9%9D%A2%E8%AF%95-JVM-GC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB-%E6%95%B4%E7%90%86%E8%A1%A8%E6%A0%BC.png)

- Serial
- Parallel
- CMS
- G1
- ZGC【jdk11+，略】

##### Serial

串行垃圾回收器

为单线程环境设计，**只使用一个线程进行垃圾回收，会<u>暂停用户进程</u>**

可以通过如下的配置，使用不同的 GC

`UseSerialGC` ~~`UseSerialOldGC`已废弃~~ `UseParNewGC`（只是在新生区使用并行）

---

![面试-JVM-GC-Serial GC-线程示意图](img/%E9%9D%A2%E8%AF%95-JVM-GC-Serial%20GC-%E7%BA%BF%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

上图为同时使用了 `SerialGC` 和 `SerialOldGC`，分别控制新生代和老年代中的垃圾收集器

对于没有线程交互的系统开销可以获取最高的单线程垃圾收集效率，因此 <u>`Serial` 垃圾收集器依然是 Java 虚拟机运行在 Client 模式下的新生代垃圾收集器</u>

- `-XX:+UseSerialGC`

  年轻代使用 *串行垃圾收集器* **复制算法**；老年代使用 *串行垃圾收集器* **标记-整理算法**

---

![面试-JVM-GC-ParNew GC-线程示意图](img/%E9%9D%A2%E8%AF%95-JVM-GC-ParNew%20GC-%E7%BA%BF%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

**ParNew 收集器其实就是 Serial 收集器新生代的并行多线程版本**，最常见的应用场景是<u>配合老年代的 CMS GC</u> 工作，其余的行为与 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样要暂停所有其他线程

**这是很多 Java 虚拟机运行在 Server 模式<u>新生代</u>中的默认垃圾收集器**

- `-XX:+UseParNewGC`

  *启动 ParNew 收集器*，<u>只会影响新生代</u>，不会修改老年代中的垃圾收集器

  因此，一般情况下，会导致 JVM 使用：

  新生代 *并发垃圾收集器* **复制算法**；老年代 *串行垃圾收集器* **标记-整理算法**

  ~~在 JDK8 中，已经不再推荐出现 `ParNew`+`Serial Old` 的组合~~

  其中可以使用 `-XX:ParallelGCThreads=[size]` 调整 `ParNew` 的线程数量（默认情况下与CPU数量相同）

##### Parallel

并行垃圾回收器

**多个垃圾收集线程并行工作，此时<u>用户线程是暂停的</u>，相比起来 GC 效率更高**

*适用于科学计算*

`UseParallelGC` `UseParallelOldGC`

---

![面试-JVM-GC-Parallel GC-线程示意图](img/%E9%9D%A2%E8%AF%95-JVM-GC-Parallel%20GC-%E7%BA%BF%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

Parallel Scavenge 收集器类似 `ParNew` 也就是一个**新生代**垃圾收集器，使用复制算法，也是一个并行的多线程垃圾收集器，俗称吞吐量优先收集器

**新生代和老年代一同使用并行优化**

- `-XX:+UseParallelGC` | `-XX:+UseParallelOldGC`

  ==JDK6 之后==

  其中任意一个配置默认会开启另一个配置（使用其中一个，会就同时开启另一个），最终导致新生代和老年代都开启并行处理

  新生代 *并行垃圾收集器*；老年代 *并行垃圾收集器*

  ==JDK6 之前==

  使用的是 `ParallelGC` + `Serial Old`

==Java8 默认的垃圾收集器==

##### CMS

并发垃圾回收器，`ConcMarkSweep`

用户和垃圾手机线程可以同时执行，不一定是并行的，可以交替执行，不需要停止用户进程

互联网系统使用最多，适用于有响应时间要求的场景

> 具体而言，用户进程还是会有极端事件的停顿（初始标记阶段），之后的各个阶段可以并发执行
>
> 准确而言，并不是完全不停止

其中的具体过程可以被分为四个部分：

1. ==初始标记== initial mark

   标记 GC roots 能够直接关联的对象，速度快，但是依然需要**暂停所有工作线程**

2. ==并发标记== concurrent mark （和用户线程一起工作）

   进行 GC roots 的跟踪过程，和用户线程一起工作，不需要暂停工作线程

   <u>主要标记过程，标记全部对象</u>

3. ==重新标记== remark

   修正<u>并发标记</u>期间，因用户程序的继续运行而导致的标记产生变动的那一部分对象的标志记录，仍然需要暂停所有的工作线程 *二次确认*

   由于并发标记值，用户线程依然运行，因此在正是清理前，需要再次修正

4. ==并发清除== concurrent sweep （和用户线程一起工作）

   清除 GC roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记的结果，直接清理对象

   由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户一起并发工作，所以**总体上 CMS 收集器的内存回收和用户线程是一起并发执行**

> - 优点
>
>   **并发收集低停顿**
>
> - 缺点
>
>   - 并发执行，对 CPU 资源压力大
>
>     由于并发进行，CMS 在收集和应用线程<u>会同时增加对堆内存的占用</u>，也就是说，<u>CMS 必须要在老年代堆内存耗尽之前完成垃圾回收</u>
>
>     CMS 回收失效时，将触发**担保机制**，串行老年代收集器将会以 STW 的方式进行一次 GC 从而造成较大的停顿时间
>
>   - 采用标记清楚算法，会导致大量内存碎片
>
>     标记清除算法无法整理空间碎片，老年代空间会随着应用运行而逐步耗尽，最后不得不通过**担保机制**对堆内存进行压缩
>
>     CMS 提供了参数 `-XX:CMSFullGCsBeForeCompaction=[value]`（默认值0，即每次都会进行内存整理）来指定多少次 CMS 收集后，进行一次压缩的 Full GC

> CMS 中可能出现的错误
>
> - `promotion failed`
>
>   该问题是在进行Minor GC时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的。（promotion failed时老年代CMS还没有机会进行回收，又放不下转移到老年代的对象，因此会出现下一个问题concurrent mode failure，需要stop-the-wold 降级为GC-Serail Old）
>
> - `concurrent mode failure`
>
>   该问题是在执行CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足，或者在做Minor GC的时候，新生代Survivor空间放不下，需要放入老年代，而老年代也放不下而产生的

`UseConcMarkSweep`

---

![面试-JVM-GC-CMS GC-线程示意图](img/%E9%9D%A2%E8%AF%95-JVM-GC-CMS%20GC-%E7%BA%BF%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

CMS，Concurrent Mark Sweep，并发标记清除，**是一种以获取最短回收停顿时间为目标的收集器**

适用应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，**希望系统停顿时间最短**

CMS适合在堆内存大、CPU核数多的服务器端应用，也是 G1 出现前大型应用的首选收集器

**并发收集低停顿，并发指的是与用户线程一起执行**

- `-XX:+UseConcMarkSweepGC`

  开启该参数之后，会自动开启 `-XX:+UseParNewGC`

  之后会适用 `ParNew`（Young）+ `CMS`(Old) + `Serial Old`（Old）

  <u>此处的 `Serial Old` 将作为 CMS 出错的**后备收集器**</u>

##### G1

==JDK 8 之后==

G1 垃圾回收器

**将堆内存分割成不同的区域然后并发的对其进行垃圾回收，不会出现内存碎片**

> 为了更加深入感受 G1 所带来的变化，需要首先知道**之前的垃圾回收器的特点**
>
> - 年轻代和老年代是**各自独立**且**连续**的内存块
> - 年轻代收集使用 eden + s0 + s1 进行复制算法
> - 老年代收集必须扫描**整个老年代区域**
> - 都是以尽可能少而快速地执行 GC 为设计原则
>
> 主要的修改就是将原本的 eden survivor 和 tenured 等区域不再连续，而是变成了一个个大小相同的 region，每个 region 从 1m 到 32m 不等
>
> 一个 region 可能属于 eden survivor 或者 tenured 内存区域
>
> ---
>
> G1 的一个重要的作用就是**用于替换 CMS** 作为一个更加强大的**服务器端垃圾回收器**，能够解决 CMS 中出现的内存碎片问题
>
> 1. G1 充分利用了多 CPU、多核环境硬件优势，尽量缩短 STW（Stop-the-World）
> 2. G1 整体上采用**标记-整理算法**，局部是通过复制算法，不会产生内存碎片
> 3. 宏观上来看 G1 中不再区分年轻代和老年代，将内存划分为多个独立的子区域 `region`
> 4. G1 收集器里面讲整个的内存区都混合在一起了，但其**本身依然在小范围内要进行年轻代和老年代的区分**，保存了新生代和老年代的概念，只是不再有物理上的隔离，而是 `region` 集群且不需要 `region` 连续，也就是说依然会采用不同的 GC 方式来处理不同的区域
> 5. G1 虽然也是分代收集器，但是整个内存分区**不存在物理上**的年轻代和老年代的区别，也不需要完全独立的 survivor 堆做复制准备
> 6. G1 **只有逻辑上的分代概念**，或者说每个分区都可以随着 G1 的运行而在不同代之间前后切换

G1 使用了 `region` 内存分片的思想，整体划分为了大小相同的不连续内存区域，**避免了全内存的 GC 操作**

其中的 `region` 大小一般是 JVM 启动时自动设置，也可以自行手动设置 `-XX:G1HeapRegionSize=[size]`（大小可以设置 1m~32m，且必须是2的幂），默认情况下会将整个堆划分为 2048 个分区

> G1 的内存大小，其范围在 1m~32m，最多 2048 个区域，因此，最大的内存为 $32m * 2048 = 65536m = 64g$，即最大指定的内存为 64G

因为在 G1 中，基本上废弃了之前使用的内存结构，此处为其特殊的内存使用示意图

![面试-JVM-GC-G1-内存使用结构图](img/%E9%9D%A2%E8%AF%95-JVM-GC-G1-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png)

> 其中的 `Humongous` 表示超大对象，需要单独处理
>
> 如果大对象大到超出了 `region` 的大小，就会使用连续的 `region` 来一同存储该对象

> **G1 常用参数**
>
> `-XX:+UseG1GC` 开启 G1 垃圾回收器
>
> `-XX:G1HeapRegionSize=[size]` 设置 G1 区域的大小，值为2的幂，范围是 1MB 到 32MB，目标是根据最小的 Java 堆大小划分出约 2048 个区域
>
> `-XX:MaxGCPauseMilis=[time]` 最大 GC 停顿时间，是一个软目标，JVM 会尽可能向其靠拢（但不保程能够做到），使用规定时间内完成 GC 操作
>
> `-XX:InitiatingHeapOccupancyPercent=[次数]` 堆占用了多少的时候触发 GC，默认为45
>
> `-XX:ConcGCThreads=[threads]` 并发 GC 使用的线程数
>
> `-XX:G1ReservePercent=[percent]` 设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险，默认值为 10%

`UseG1GC`

---

![面试-JVM-GC-G1-线程示意图](img/%E9%9D%A2%E8%AF%95-JVM-GC-G1-%E7%BA%BF%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

可以横向对比 CMS，各个阶段基本相同，最终使用的依然是标记清除算法，但是因为各个 `region` 又可以被移动，因此，在宏观上，还是没有内存碎片（其实各个 `region` 中应该都会有内存碎片，所谓的没有内存碎片应该是宏观而言）

#### 垃圾收集器配置

此处主要解决如下几个问题

> 怎样查看服务器默认的垃圾收集器？
>
> 生产上如何配置垃圾收集器？

可以通过 `-XX:+PrintCommandLineFlags` 命令，来显示相关的信息，默认情况下，一般是并行垃圾回收器 `Parallel`

可以通过使用如下的命令来开启不同的 GC 回收器

- ==新生代==

- `UseSerialGC`

- `UseParallelGC`

- `UseParNewGC`

  ---

- ==老年代==

- ~~`UseSerialOldGC`废弃~~

- `UseParallelOldGC`

- `UseConcMarkSweepGC`

  ---

- ==最特殊，将内存进行划分==

- `UseG1GC`

> 部分参数说明
>
> - `DefNew` Default New Generation 默认的年轻代
> - `Tenured` Old 永久的/老年的
> - `ParNew` Parallel New Generation 并行年轻代
> - `PSYoungGen` Parallel Scavenge Young Generation 并行清除年轻代
> - `ParOldGen` Parallel Old Generation 并行老年代

#### 拓展

##### G1 和 CMS 比较的优势

1. G1 不会产生内存碎片（准确应该是不会产生太大的内存碎片）
2. 可以控制停顿（虽然并不决定能够达到，但是一定程度上确实可以控制）

### 配置参数

在 JVM 中的配置参数

> 此处的配置以 JDK8 为主，因此可能出现其他版本，如14、11 中并不适用的配置

#### 参数类型

主要可以被分为三种

##### 标配参数

主要表示 JVM 配置参数中各个版本通用的参数，基本上不会因为版本迭代而导致失效

- `-version`
- `-help`
- `-showversion`

##### X 参数

调整 Java 执行逻辑，默认为 `-Xmixed`【**了解即可**】

- `-Xint`

  解释执行

- `-Xcomp`

  第一次使用就编译成本地代码

- `-Xmixed`

  混合模式

##### XX 参数【重点】

JVM 中**重要**的配置参数，可能会因为版本的不同而发生变化

###### Boolean 类型

表示是否开启某种设置，只有两种状态

其格式一般为 `-XX:+/-[某个属性]`。其中 `+` 表示开启；`-` 表示关闭

- `PrintGCDetails`

  是否打印 GC 收集细节

- `UseSerialGC`

  是否使用串行垃圾回收器

###### KV 设值类型

用于设置某个属性的具体值

其格式为 `-XX:[key]=[value]`

- `MetaspaceSize=[原空间大小]`

  原空间大小

- `MaxTenuringThresHold=[迭代次数]`

  配置新生代需要经过多少次 GC 才能晋升到老年代

- `InitialHeapSize` => 简写 `-Xms`

  堆初始大小

- `MaxHeapSize` => `-Xmx`

  堆最大内存

###### jinfo 查看配置

能够查看正在运行中的 Java 程序的各种信息，包括其中的 JVM 的配置信息（默认配置值等）

```shell
# 结合 jps 使用
# 通过使用 jinfo 查看某个 Java 程序的配置
jinfo -flag [某个配置] [Java 进程号]

# 可以列出某个 Java 程序可以获取到的所有配置（不等于 JVM 中的所有配置）
jinfo -flags [Java 进程号]
# 其中列出的配置，存在 JVM 根据机器性能进行动态修改的配置 Non-default
```

#### 查看 JVM 默认值

虽然通过 `jinfo` 能够实现查看 JVM 配置默认值的功能，但是其中查看并不完整（使用 `-flags`）或是需要记住各个配置的名称 【[跳转 jinfo](#jinfo 查看配置)】

此处还有更加实用的方式，可以查看 JVM 中的配置信息

- `java -XX:+PrintFlagsInitial [-version]`

  开启显示 JVM 默认配置参数，主要指出厂默认值

  能够直接使用以上命令，能够查看 JVM 的默认配置参数

- `java -XX:+PrintFlagsFinal -version`

  开启显示 JVM 默认配置，主要表示的是修改或更新之后的参数

  > 通过以上的两个命令，都可以显示 JVM 中的所有配置信息
  >
  > ![面试-JVM-配置参数-查看配置信息-不同等号的意义](img/%E9%9D%A2%E8%AF%95-JVM-%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0-%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF-%E4%B8%8D%E5%90%8C%E7%AD%89%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89.png)
  >
  > 其中存在两种不同的等号
  >
  > - 单纯的等号
  >
  >   表示使用 JVM 默认的配置
  >
  > - 等号之前有一个冒号
  >
  >   表示配置发生过变化
  >
  >   表示在之后进行了人为修改或是 JVM 动态进行了修改

- `java -XX:+PrintCommandLineFlags -version`

  查看 JVM 中最常用的几个参数

  其中主要可以查看 JVM 的默认 GC 类型

#### 常见配置参数

此处再次列举最常用的 JVM 配置参数（可能与之前的参数类型中列举的内容有重复）

- `-Xms[Size]|-XX:InitialHeapSize=[Size]`

  默认堆内存大小，默认为物理内存的 1/64

- `-Xmx[Size]|-XX:MaxHeapSize=[Size]`

  最大分配内存，默认为物理内存的 1/4

- `-Xss[Size]|-XX:ThreadStackSize=[Size]`

  各个线程的栈大小，默认情况一般为 512k~1024k

  > 此项的配置会根据不同的平台不同而不同，此处的默认值指的是 Linux 中的默认大小
  >
  > 如果通过之前的方式来查看 `ThreadStackSize` 的值（此处为 WIndows），一般都是只能看到 0。官方文档中描述其会根据虚拟内存进行配置

- `-Xmn[Size]`

  调整新生代的大小，默认情况下新生代的大小为 $1/3$ 的堆空间

- `-XX:MetaspaceSize=[Size]`

  调整元空间大小

  > 元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。元空间与永久代之间的最大区别在于：
  >
  > **元空间并不在虚拟机中，而是使用本地内存**
  >
  > 因此，<u>默认情况下，元空间的大小仅受本地内存的限制</u>。但是，元空间依然存在 OOM 的可能性

- `-XX:+PrintGCDetails`

  显示 GC 回收的细节

  > 其中显示的具体细节，因为 GC 类型的不同，其显示的细节信息也不同
  >
  > ==GC 的回收细节==
  >
  > ![面试-JVM-GC-显示GC细节-GC回收具体信息](img/%E9%9D%A2%E8%AF%95-JVM-GC-%E6%98%BE%E7%A4%BAGC%E7%BB%86%E8%8A%82-GC%E5%9B%9E%E6%94%B6%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF.png)
  >
  > 其中的 `PSYongGen` 表示的新生代，其中的 `PS` 代表的是 `parallel scanvenge`
  >
  > ==Full GC 回收细节==
  >
  > ![面试-JVM-GC-显示GC细节-FullGC回收具体信息](img/%E9%9D%A2%E8%AF%95-JVM-GC-%E6%98%BE%E7%A4%BAGC%E7%BB%86%E8%8A%82-FullGC%E5%9B%9E%E6%94%B6%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF.png)
  >
  > 永久代 `PSPermGen`，之后被替换为元空间 `Metaspace`
  >
  > ==规律==
  >
  > ![面试-JVM-GC-显示GC细节-显示规律](img/%E9%9D%A2%E8%AF%95-JVM-GC-%E6%98%BE%E7%A4%BAGC%E7%BB%86%E8%8A%82-%E6%98%BE%E7%A4%BA%E8%A7%84%E5%BE%8B.png)

- `-XX:SurvivorRatio=[比例]`

  幸存区中的划分比例（伊甸区、from区和to区）

  默认情况下为8，表示伊甸区为 8，from和to为1

  > 如果设置为4，表示 `eden:s1:s0 = 4:1:1` 

- `-XX:NewRatio=[比例]`

  配置年轻代和老年代在堆结构中的占比（因为 JDK8 中元空间退出堆空间，使用本地内存，因此这里的配置一般不包括元空间）

  默认情况下为2，表示新生代为1，老年代为2，表示整个年轻代占整个堆的 1/3

  > 如果设置为4，表示新生代占1，老年代为4，年轻代占整个堆的 1/5

  > 如果 `-Xmn` 和 `-XX:NewRatio` 同时配置，将会以 `-Xmn` 为主

- `-XX:MaxTenuringThreshold=[次数]`

  配置新生代中的对象通过几次垃圾回收之后就会进入老年代

  默认值为15，表示需要经过15次 GC 垃圾回收依然存活，就会进入老年代

### 引用分类

Java 中，引用可以被细分为4种

- 强引用【默认】
- 软引用
- 弱引用
- 虚引用

引用架构图如下

![面试-JVM-引用分类-引用架构图](img/%E9%9D%A2%E8%AF%95-JVM-%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB-%E5%BC%95%E7%94%A8%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

#### 强引用

==Java 中默认支持的模式==

当内存不足时，JVM 开始垃圾回收，对于强引用的对象，<u>就算是出现了 OOM 也不会对该对象进行回收</u>

强引用就是我们常见的普通对象引用，主要还有强引用指向一个对象，就能表明对象还**活着**，垃圾回收器不会操作这种对象。在 Java 中最常见的就是强引用，将对象赋给一个引用变量，这个引用变量就是一个强引用

当一个对象被强引用变量引用时，其可能处于一种可达状态（GC 算法），不会被垃圾回收器回收，即<u>视对象之后永远不会被使用，也不会被 JVM 回收</u>

因此，*强引用时造成 Java 内存泄漏的主要原因之一*

对于一个普通对象，如果没有其他的引用关系，只要<u>超过了引用的作用域或者显示地将对应强引用赋值为 `null`，就表示该对象可以被垃圾回收</u>（具体的回收时机依然还是要看垃圾回收策略）

#### 软引用

软引用相对于强引用两者的关系更弱的一种引用方式，需要使用 `java.lang.SoftReference` 类来实现，可以让对象豁免一些垃圾回收

一定程度上，可以降低 OOM 的概率

对于只有软引用的对象来说

- 当系统内寸**充足**时，**不会**被回收
- 当系统内存**不足**时，**会**被回收

==软引用通常用在对内存敏感的程序中==，如高速缓冲中就有使用到软引用，<u>内存够用的时候就会进行保存，如果不够就会回收</u>

```java
// 声明一个对象
Object o1 = new Object();
// 使用软引用
SoftReference<Object> softReference = new SoftReference<>(o1);

// 使用对象
System.out.println(o1);
// 获取软引用的对象，并输出
System.out.println(softReference.get());

// 将 Object 对象显式复制为 null，并调用垃圾回收
o1 = null;
System.gc();

// 使用对象 null
System.out.println(o1);
// 依然指向刚才的对象
System.out.println(softReference.get());
```

#### 弱引用

弱引用相较于软引用，其联系更加松弛，说明其引用的生存期更短

对于弱引用的对象来说，<u>只要发生了垃圾回收机制，不管 JVM 内存空间是否充足，都会被回收</u>

```java
Object o1 = new Object();
WeakReference<Object> weakReference = new WeakReference<>(o1);

// 操作对象
System.out.println(o1);
System.out.println(weakReference.get());

// 将 Object 显式赋值为 null，并调用垃圾回收
o1 = null;
System.gc();

// 发现弱引用被垃圾回收
System.out.println(o1);
System.out.println(weakReference.get());
```

##### WeakHashMap

WeakHashMap 继承了 AbstractMap，实现了 Map 接口

与 HashMap 一样，WeakHashMap 也是散列表，其存储的也是键值对，即 key-value 映射，并且键与值都可以是 `null`

但是 WeakHashMap 的键是**弱键**，即当某个键所对应的对象不能正常使用，也就是被垃圾回收之后，WeakHashMap 中对应的元素也会被自动回收

```java
WeakHashMap<Integer, String> hashMap = new WeakHashMap<>();

Integer key = new Integer("1");
String value = "WeakHashMap";
hashMap.put(key, value);

Integer k1 = new Integer("2");
String v1 = "test";
hashMap.put(k1, v1);

System.out.println(hashMap + "\tsize=" + hashMap.size());

// 将 key 显式赋值为 null
// 如果没有将 key 设置为 null，直接进行垃圾回收，不会将 WeakHashMap 中的元素清空
key = null;
// System.out.println(hashMap);

// 垃圾回收，如果此处的 key 已经被设置为 null，就会对其对应的元素进行回收
System.gc();
System.out.println(hashMap + "\tsize=" + hashMap.size());
```

#### 虚引用

虚引用，又被称为幽灵引用。需要通过实现 `java.lang.ref.PhantomReference` 类来实现

顾名思义，就是形同虚设，与其他几种引用都不同，**虚引用并不会决定对象的生命周期**

**如果一个对象仅持有虚引用，等同于没有任何引用一样，在任何时候都可能被垃圾回收器回收**，不能单独使用也不能通过虚引用来获取对象，虚引用必须和引用队列 `ReferenceQueue` 联合使用

> “虚引用不能获取对象” 表现为 `get()` 方法返回一定是 `null`

虚引用的作用主要是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被 `finalize` 之后，做某些事情的机制。可以说明一个对象已经进入了 `finalization` 阶段，可以被 GC 回收，用来实现比 `finalization` 机制更加灵活的回收机制

使用虚引用的唯一目的，就是在这个对象被 GC 回收的时候收到一个系统通知或者后续添加进一步处理。Java 计数允许使用 `finalize()` 方法在垃圾回收器将对象从内存中清除出去之前做必要的清理工作

##### 引用队列

引用队列主要作用就是在几种引用的创建时，一同使用，可以用于对象被 GC 回收前临时存放

在这段时间内，可以做出更多的操作

```java
// 声明对象、引用队列、弱引用（此处使用弱引用来感受引用队列的使用）
Object o1 = new Object();
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
// 在构造方法中传入引用队列
WeakReference<Object> weakReference = new WeakReference<>(o1, referenceQueue);

System.out.println(o1);
System.out.println(weakReference + " : " + weakReference.get());
System.out.println(referenceQueue.poll());

System.out.println("===================");
o1 = null;
System.gc();
// 可以在此处 sleep 一段时间，确保完成了 GC 操作
try {
  TimeUnit.MILLISECONDS.sleep(300);
} catch (InterruptedException e) {
  e.printStackTrace();
}

System.out.println(o1);
System.out.println(weakReference.get());
// 引用队列中可以获取到对应的对象（此处获取的是引用的对象，即弱引用对象）
// 偶尔获取会返回null，如果使用了 sleep 就不会出现这个问题
System.out.print("ReferenceQueue : " + referenceQueue.poll());
```

> 使用虚引用也一样，唯一的区别就是 `get()` 方法不能获取到具体的值

#### 使用场景

##### 软引用和弱引用

相比起强引用，软引用和弱引用的稳定性更差，但是能够在一定程度上避免 OOM 的发生，可以用于某些缓存的使用场景

<u>在内存充足时，使用空间交换时间；当内存不足时，使用时间换空间</u>

这样的过程可以自动转换

> 在 MyBatis 中使用了软引用

##### 虚引用

主要用于在对象回收前进行其他更多的操作，**必须结合引用队列使用**

### OOM

OOM，一般指的是 `Out Of Memory`，表示内存耗尽

其中包括各个<u>不同的区域发生了 OOM</u>，导致其又能被具体划分为不同的情况

- `java.lang.StackOverflowError`

  栈内存溢出

- `java.lang.OutOfMemoryError:java heap space`

  堆内存溢出，一般两种情况

  1. 一直创建不同的对象
  2. 创建超大对象（比堆还要大，可以使用 `-Xms` 和 `-Xmx` 进行设置）

- `java.lang.OutOfMemoryError:GC overhead limit exceeded`

  使用了过量的时间在执行 GC 回收，即频繁需要进行 GC 垃圾回收，且每次回收清理出的空间又被快速占满，并再次需要进行 GC 回收，导致了恶性循环

  使得 CPU 使用率一直居高，而 GC 垃圾回收也没有效果

  ```java
  int i = 0;
  List<String> list = new ArrayList<>();
  
  try {
    while (true) {
      list.add(String.valueOf(++i).intern());
    }
  } catch (Throwable e) {
    System.out.println("i = " + i);
    e.printStackTrace();
  }
  ```

  > 控制台中会出现大量的 GC 回收操作，最终出现 `Out Of Memory: GC overhead limit exceeded` 错误

- `java.lang.OutOfMemoryError:Direct buffer memory`

  直接内存不足

  > 可以通过使用 `-XX:MaxDirectMemorySize=[size]` 来修改直接内存的大小，如果此时使用 NIO 中的 `allocateDirect([capability])` 来获取直接内存缓冲，如果超出了直接内存大小，就会出现这个错误
  >
  > ==NIO 相关的程序中经常出现==

- `java.lang.OutOfMemoryError:unable to create new native thread`

  不能再创建本地线程（在 `Thread` 源码底层最终调用的是 `native` 的 `start0()` 方法）

  一般出现在高并发的系统中常见，一般与平台有关（Linux 系统默认一个程序可以创建 `1024` 个线程）

  > 在 Linux 系统下查看具体的线程上线
  >
  > `ulimit -u` 查看用于的应用线程数限制
  >
  > `vim /etc/security/limits.d/20-nproc.conf ` 配置文件（具体的配置文件名可能不同，如 `20-nproc.conf` 编程 `90-nproc.conf` 等）
  >
  > 在配置文件中记录的不同的用户的应用线程限制，可以指定具体的用户的线程限制

  > **解决思路**
  >
  > 1. 想办法江都应用程序的线程数，分析是否真的需要这么多的线程，如果不是，尽量降低线程数量
  > 2. 对于有的应用，需要创建很多的线程，并远超 Linux 系统的默认 1024 个线程的限制，可以通过修改 Linux 服务器配置，扩大 Linux 默认限制

- `java.lang.OutOfMemoryError:Metaspace`

  元空间内存不足

  一般是因为动态加载太多的类（尤其是反射加载了大量的类）或是方法，可能出现这个错误

## 项目调优

此处主要是项目运行期间的测试和调优，主要是 Linux 系统下

### 项目发布优化

项目发布之前，为了能够在服务器环境下更好得运行，主要需要各种 JVM 调优

此处主要是 JVM 以及 GC 的调整

- 内

  在 IDE 环境下的测试调优参数，使用 VM options 功能进行调整

- 外

  在实际的环境下测试各个参数，此处主要需要借助 `jps` 和 `jinfo` 两个命令

### 诊断系统情况

主要针对几个不同的方面，从上往下依次测试，对于具体的每一项又需要使用总分的方式进行排查

#### 整机 `top`

- 查看进程的 CPU 和内存 MEM 占用
- 查看系统的负载均衡 `load average` 三个值，**如果三个值的平均值大于 0.6 说明系统的负载较重**
- 点击数字键 1，可以显示各个 CPU 的具体信息

---

还可以使用精简版的命令 `uptime`，可以显示系统的负载均衡

#### CPU `vmstat`

```shell
# 命令需要添加两个参数
vmstat -n [n1] [n2]
# n1 表示间隔时间
# n2 表示取样多少次
```

在 `vmstat` 的结果中，主要关注如下的内容

- `procs`
  - `r` 运行队列

    通过此数据计算平均值，如果超出 CPU 数目，就会出现 CPU 瓶颈

    原则上，运行和等待的 CPU 时间片的进程数，最好运行队列的数量不要超过总核数的 2 倍，否则表示系统的压力过大

  - `b` 阻塞队列

    等待资源的进程数，如正在等待磁盘 I/O、网络 I/O 等

- `cpu`

  - `us` 用户进程占用 CPU 时间百分比

    此处的值越高，表示用户进程消耗 CPU 时间多，如果长期大于 50%，就需要优化进程

  - `sy` 内核进程消耗的 CPU 时间百分比

  > 最终 `us + sy` 的参考值一般为 80%，如果大于 80%，说明可能存在  CPU 不足

  - `id` 处于空闲的 CPU 百分比
  - `wa` 系统等待 IO 的 CPU 时间百分比
  - `st` 来自一个虚拟机偷取的 CPU 时间的百分比

---

查看所有 CPU 核信息 `mpstat -P ALL [间隔时间]`

主要关注其中的 `idle` 值（系统空闲率），理论上越高越好

---

每个进程使用 CPU 的用量分解信息 `pidstat -u [间隔时间] -p [进程编号]`

可以针对某个进程的具体资源占用，其中可以分别显示用户占用 `usr` 和系统占用 `system`

#### 内存 `free`

```shell
# 其中可以选择不同的输出显示（主要指的是输出的单位）
free
# 如果没有参数，会显示系统的内存总占用

# -g
# 表示使用 GB 作为单位显示

# -m
# 表示使用 MB 作为单位显示
```

其结果会显示以下的信息

- `total` 系统总内存
- `used` 占用内存
- `free` 空闲内存

> 一般情况下，应用进程占用小于 70% 都是没有任何问题

---

查看具体的内存信息 `pidstat -r [间隔时间] -p [进程编号]`

查看其中显示的 `MEM`，最好小于等于 1

#### 硬盘 `df`

```shell
# 显示磁盘内存占用
df
# 默认的显示格式，使用 B 作为单位

df -h
# 将会使用可读性更强的单位显示内存信息
```

#### 磁盘 IO `iostat`

```shell
# 显示硬盘 IO 信息
iostat -xdk [间隔时间] [打印次数]
```

结果中主要关注如下的信息

- `rkB/s` 每秒读取数据量，单位 kb
- `wkB/s` 每秒写入数据量，单位 kb
- `svctm` I/O 请求的平均服务时间，单位 ms（毫秒）
- `await` I/O 请求的平均等待时间，单位 ms；值越小越好
- `util` 一秒中有百分几的时间用于 I/O 操作【**重要**】

> `rkB/s`、`wkB/s` 根据系统应用会有不同的值，但有一定的规律：长期、超大数据读写，肯定不正常，需要优化程序读取
>
> 一般来说 `await` 越小，性能越高。`svctm` 和 `await` 的值很接近，表示几乎没有 I/O 等待，磁盘性能好；如果 `await` 远高于 `svctm`，则表示 I/O 队列等待时间过长，需要优化程序或更换更快的磁盘
>
> ==`util` 接近 100% 时，表示磁盘宽带被完全占用，需要优化程序或者增加磁盘==

---

查看磁盘 I/O 额外信息 `pidstat -d [间隔时间] -p [进程编号]`

#### 网络 IO `ifstat`

可以显示系统中的网络输入输出信息

> 原生系统中可能没有，需要安装

### 系统诊断思路

> 生产环境中，CPU占用过高
>
> 分析思路和定位

主要结合 Linux 和 JDK 命令一同使用进行分析

#### 大概的案例步骤

1. 定位某个具体的**进程**

   首先使用 `top` 命令找出 CPU 占比最高的程序（Java 程序）

   `ps -ef` 或者 `jps` 进一步定位，得知是一个怎样的后台程序导致 CPU 占用过高

2. 定位具体**线程**或者代码

   使用 `ps -mp [进程编号] -o THREAD,tid,time` 命令，能够定位到其中的某个具体的线程（通过其中的 `CPU` 占用，产看对应的 `TID` Thread id）

   > 其中的各个参数的含义
   >
   > - `-m` 显示所有的线程
   > - `-p` pid 进程使用 CPU 的时间
   > - `-o` 参数之后定义用户的输出格式（自定义格式）

3. 线程 ID 转换

   在系统中，线程 ID 需要转换为 16 进制格式（**英文小写**）

   使用 `print "%x\n"` 打印对应的 ID 即可自动转换【提供一种思路，不唯一】

4. 显示线程的运行状态

   `jstack [pid] | grep [tid] -A60`

   能够从结果中，直接定位占用 CPU 较高的某个段具体代码

### Java 工具

Java 中内置的工具

> 详细内容，可以查看官方文档
>
> https://docs.oracle.com/javase/8/docs/technotes/tools/windows/index.html

最常见的主要有如下

- `jps` 虚拟机进程状态工具
- `jinfo` Java 配置信息工具
- `jmap` 内存映射工具
- `jstat` 统计信息监视工具
- `jstack` 栈堆异常跟踪工具
- `jconsole` Java 简单的图形控制器
- `jvisualvm` Java 图形控制器

## GitHub

GitHub 下的相关提升操作，能够在之后的工作中使用

### 常用词

GitHub 上的常用词概念

- `watch` 会持续收到该项目的动态
- `fork` 复制某个项目到自己的 GitHub 仓库中
- `star` 等同于点赞
- `clone` 将项目下载到本地
- `follow` 关注，关注某个作者，之后可以收到其动态

### 搜索项目

GitHub 中搜索项目的各种操作，最终定位到某个具体的项目

#### 精确搜索

##### 限制标题、描述、readme

限制搜索的内容，能够得到更加精确的响应信息

可以使用 `in` 关键字，限制其搜索的范围

- `in:name` 表示在项目名中包含关键字
- `in:description` 项目描述中包含关键字
- `in:readme` 项目readme文件中包含关键字

> 可以组合使用，即多个部分中都要出现关键字，如 `in:name,description` 表示在项目名和项目描述中都需要出现关键字

> **示例**
>
> 希望在 GitHub 上找到一个简单的秒杀项目的代码，希望在标题和描述中都出现关键字
>
> `seckill in:name,description`

##### 限制 star、fork

使用 `stars` 和 `forks` 关键词来进行查询

其中限制范围的符号主要有两种

- `:>=` `:>` ~~`:<=` `:<`~~
- `:[start]..[end]`

> **示例**
>
> 1. 查找一个 star 超过 5000 的 `springboot` 项目
>
>    `springboot stars:>5000`
>
> 2. 查找一个 fork 大于等于 7000 的 `springboot` 项目
>
>    `springboot forks:>=7000`
>
> 3. 查找 fork 在100到200之间，并且 star 数在80到100之间的 `springboot` 项目
>
>    `springboot fork:100..200 stars:80..100`

#### 加强搜索

GitHub 下提供的原生整理，将其中的优秀项目进行整合，形成一个个列表，通过关键字查询就能获取到相关的列表

`awesome [keyword]` 搜索出关键字相关的优秀教学项目

> **示例**
>
> 搜索 redis 相关的优秀项目，包括框架、教程等
>
> `awesome redis`

### 项目具体

项目中具体的效果，可以在项目中添加增强效果，起到更好的展示作用

#### 代码高亮

首先进入某个具体项目的的代码界面，如果需要向其他人展示其中的重要代码，可以通过以下的方式对其进行增强

- 一行

  `[具体网址]+#L[行号]`

- 多行

  `[具体网址]+#L[start]-L[end]`

> **示例**
>
> https://github.com/codingXiaxw/seckill/blob/master/src/main/java/cn/codingxiaxw/dao/SeckillDao.java
>
> 1. 在该界面中的代码，将13行进行高亮显示
>
>    https://github.com/codingXiaxw/seckill/blob/master/src/main/java/cn/codingxiaxw/dao/SeckillDao.java#L13
>
> 2. 在该界面中的代码，将16行到22行进行高亮显示
>
>    https://github.com/codingXiaxw/seckill/blob/master/src/main/java/cn/codingxiaxw/dao/SeckillDao.java#L16-L22

#### 项目内搜索

进入某个具体的项目之后，为了查找某个具体的类，如果使用其本身的层级界面显得十分麻烦

此时，可以使用快捷键 `t`（直接在项目界面中使用）

可以将项目中的所有类，转换为列表显示（各个类前包括其全类名）

### 用户相关

从 GitHub 中，查找其中的大佬

可以通过不同的参数限制其用户的来源，以及使用的语言

- `location:[地区]`
- `language:[语言]`

> **示例**
>
> 搜索北京的 Java 方向用户
>
> `location:beijing language:java`

## 剑指 Offer

### 有序数组 目标数

#### 题目描述

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

#### 主要思路

##### 蛮力法

遍历数组，并循环比较所有的值

这样的最差时间效率为 **O(n^2^)**

##### 边角查找

在本题中，主要提到了，所提供的二维数组是一个有序的数组。其中各行从左到右依次增大，各列从上到下依次增大。因此，整体而言，其呈现了左上到右下的依次增大

利用这样的特性，可以将比较的起始点设置到右上角或左下角，就可以通过当前值与目标值的大小关系，每次选择横向或是纵向进行一次移动

这样的方式，有一个最大的优点，就是两个方向都只会单向比较一次

这样的思路，最差的时间效率也是 **O(n)**

##### 错误思路

通过审题，可能会出现一个错误的思路

从原点（0,0）出发，直接比较一个方向的位置，再确定另一个方向的位置

这样的思路是有明显错误的，因为两个方向之后的数据大小并没有绝对的关系

#### 实现代码

##### 边角查找

```java
/**
 * @param target 目标值
 * @param array 有序数组
 * @return 返回在有序数组中查找目标值的结果
 */
public boolean Find(int target, int [][] array) {
  if(array == null){
    return false;
  }
  int rows = array.length;
  int cols = array[0].length;
  if(rows <= 0 || cols <= 0){
    return false;
  }
  // 将循环的起始位置放在左下角
  // 此处的值，在数组中，行最小，列最大
  // 因此，如果比target大，就减小行数；如果比target小，就加大列数
  int row = 0;
  int col = cols -1;
  // 如果比较到了最后依然没有遇到相同的值，就退出循环
  while(row < rows && col >= 0){
    if(array[row][col] == target){
      return true;
    }else if(array[row][col] > target){
      -- col;
    }else{
      ++ row;
    }
  }
  return false;
}
```

### 链表 逆序 ArrayList

#### 题目描述

输入一个链表，按链表从尾到头的顺序返回一个ArrayList

#### 主要思路

##### 使用栈

使用栈 `Stack` 的 `push()` 和 `pop()` 方法，先将链表中的数据存放到栈中，之后逆序输出，并放入 `ArrayList` 中

##### 使用Collections

直接将链表的值放入 `ArrayList` 中，最后借助 `Collections` 工具类中的 `reverse()` 方法，将 `ArrayList` 反向

##### 使用add(int, E)

在 `ArrayList` 中，存在 `add()` 方法的重载，其中需要两个参数

- `int index` 添加的下标
- `E element` 添加的元素

会根据下标来进行插入值，同时，如果原本的下标上已经有值，就会将对应下标以及之后的数据依次向后移动

#### 实现代码

此处因为使用 `Collections` 和 `add(int, E)` 的代码都很类似，因此直接不分别列出

```java
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
import java.util.Collections;
public class Solution {
  ArrayList<Integer> list = new ArrayList<>();
  public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    if (listNode == null) return list;

    while (listNode != null) {
      // 使用 add(int, E) 的方式
      // 不需要使用额外的代码，最方便实现
      // list.add(0, listNode.val);
      list.add(listNode.val);
      listNode = listNode.next;
    }

    // 使用 Collections 的方式
    // 调用工具类中的 reverse() 方法
    Collections.reverser(list);
    
    return list;
  }
}
```

### 数组 前中 二叉树

#### 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

#### 主要思路

##### 递归根节点

根据前序遍历和中序遍历的定义，可以知道以下两点

- 前序遍历的第一项，必然是树的根节点
- 中序遍历中，相对某个节点左侧的部分，如果可以确定是其子树（层次的确定需要结合前序）就必定是其左子树；相对的，其右侧的部分，如果可以确定是其子树，就一定是其右子树

借助以上两点，就可以借助递归的方式，利用前序的第一项必定是根节点的性质，来确定二叉树的分层结构。之后利用中序遍历来确定左右子树大概范围

大概的执行顺序：

1. 前序确定根节点

2. 中序根据根节点（题中确定数组中没有重复值），来确定其左右子树范围（因为前序确定了根节点，而其他的必然只能是其子树）

3. 根据中序确定的左子树和右子树范围，利用递归的方式，将切割的前序和中序重新传给方法参数

   > **特别注意**
   >
   > 前序数组中，第一项可以确定是根节点，因此需要排除
   >
   > 中序数组中，根据前序数组得到的根节点可以确定到同一个根节点，同样需要去除
   >
   > 因此，最终大致范围一般如下
   >
   > 首先，通过循环比较中序的第 `i` 项与前序根节点相同
   >
   > - 左子树，前序切割为 `[1, i + 1]`，中序切割为 `[0, i]`
   > - 右子树，前序切割为 `[i + 1, pre.length]`，中序切割为 `[i + 1, in.length]`

#### 实现代码

```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
import java.util.Arrays;
public class Solution {
  public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
    if (pre.length == 0 || in.length == 0)
      return null;
    // 对于当前的数组来说，前序遍历的第一项必定是根节点
    TreeNode root = new TreeNode(pre[0]);

    int i = 0;
    while (i < in.length && pre[0] != in[i]) {
      ++ i;
    }

    if (pre[0] == in[i]) {
      // 子树是通过传入切割过的前序和中序数组
      // copyOfRange() 切割的数组依然是左闭右开
      // 前序遍历的数组中，第一个数可以确认是根节点
      // 中序遍历的数组中，可以根据前序遍历，来确认根节点，因此可以直接将其去除

      // 利用方法递归，能够逐渐将数组细化，直到最后确定各个节点的位置
      root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1),
                                        Arrays.copyOfRange(in, 0, i));
      // 与左子树部分类似，其除去可以确定左子树和根节点的数字，其余的部分可以确定一定是右子树的部分
      root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length),
                                         Arrays.copyOfRange(in, i + 1, in.length));
    }

    return root;
  }
}
```

### 字符串 N形 输出

#### 题目描述

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "LEETCODEISHIRING" 行数为 3 时，排列如下：

L      C       I       R
E  T  O  E  S   I   I   G
E      D      H      N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："LCIRETOESIIGEDHN"。

> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/zigzag-conversion
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

####  主要思路

##### 按索引访问

通过使用迭代遍历字符串，每次判断字符应该插入的位置即可

可以通过使用 `StringBuilder` 数组，使用其数组保存对应行的字符串，每次判断位置并添加到对应的 `StringBuilder` 中

每次使用一个指针代表对应的操作行数，而指针只会在 `0` 或 `numRows - 1` 的时候反向

##### 按行访问

首先访问 行 0 中的所有字符，接着访问 行 1，然后 行 2，依此类推...

对于所有整数 k

- 行 0 中的字符位于索引 $k (2 * numRows−2)$ 处;
- 行`numRows−1` 中的字符位于索引 $ k (2⋅numRows−2)+numRows−1$ 处;
- 内部的 行 ii 中的字符位于索引  $k (2⋅numRows−2)+i$ 以及 $(k+1) (2⋅numRows−2)−i$ 处;

> 作者：LeetCode
> 链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

==简单总结==

对 k = i%(2n-2) 进行判断

- k<=n-1时候，s[i]就属于第k行
- k>n-1时候，s[i]就属于2n-2-k行

#### 代码实现

此处为使用**按行访问**

```java
class Solution {
  public String convert(String s, int numRows) {
    if(s.length()==1||numRows==1||numRows==0||s.length()==0)return s;
    StringBuilder ls[]= new StringBuilder[numRows];
    for(int i=0;i<numRows;i++){
      ls[i]=new StringBuilder();
    }
    int l = 2 * numRows - 2;
    for(int i = 0; i < s.length(); ++ i){
      int m = i % l ;
      if (m < numRows) ls[m].append(s.charAt(i));
      else ls[l - m].append(s.charAt(i));
    }
    StringBuilder res = new StringBuilder();
    for(StringBuilder lss:ls){
      res.append(lss.toString());
    }
    return res.toString();
  }
}
```

